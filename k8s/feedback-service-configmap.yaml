apiVersion: v1
kind: ConfigMap
metadata:
  name: feedback-script
  namespace: neural-hive
data:
  feedback_service.py: |
    import sys
    import subprocess
    # Instalar dependências
    subprocess.check_call([sys.executable, "-m", "pip", "install", "fastapi", "uvicorn", "pymongo", "pydantic", "-q"])

    from fastapi import FastAPI, HTTPException
    from pydantic import BaseModel, Field
    from pymongo import MongoClient
    import uvicorn
    import os
    from datetime import datetime
    from typing import Optional, List

    app = FastAPI(title="Feedback Collection Service")

    MONGO_URI = os.getenv("MONGODB_URI", "mongodb://root:local_dev_password@mongodb.mongodb-cluster.svc.cluster.local:27017/neural_hive?authSource=admin")
    client = MongoClient(MONGO_URI, serverSelectionTimeoutMS=5000)
    db = client.neural_hive
    opinions_col = db.specialist_opinions
    feedback_col = db.specialist_feedback

    print("Feedback Service started on port 8080")

    class FeedbackSubmit(BaseModel):
        opinion_id: str
        human_recommendation: str = Field(..., description="approve, reject, review_required")
        human_rating: float = Field(default=0.5, ge=0.0, le=1.0)
        feedback_notes: str = Field(default="")

    class FeedbackResponse(BaseModel):
        status: str
        feedback_id: str
        opinion_id: str
        message: str

    @app.get("/health")
    def health():
        return {"status": "healthy"}

    @app.get("/")
    def root():
        return {"service": "Feedback Collection", "docs": "/docs", "endpoints": ["/health", "/api/v1/feedback/stats", "/api/v1/opinions/pending", "/api/v1/feedback"]}

    @app.get("/api/v1/opinions/pending")
    def list_pending_opinions(limit: int = 10, specialist: Optional[str] = None):
        """Lista opiniões pendentes de feedback."""
        query = {"specialist_feedback": {"$exists": False}}
        if specialist:
            query["specialist_type"] = specialist

        opinions = opinions_col.find(query).sort("evaluated_at", -1).limit(limit)
        result = []
        for op in opinions:
            result.append({
                "opinion_id": op.get("opinion_id"),
                "specialist_type": op.get("specialist_type"),
                "confidence_score": op.get("opinion", {}).get("confidence_score"),
                "recommendation": op.get("opinion", {}).get("recommendation"),
                "risk_score": op.get("opinion", {}).get("risk_score"),
                "reasoning_summary": op.get("opinion", {}).get("reasoning_summary", "")[:100]
            })
        return {"count": len(result), "opinions": result}

    @app.post("/api/v1/feedback")
    def submit_feedback(feedback: FeedbackSubmit):
        """Submete feedback humano sobre uma opinião."""
        # Validar recomendação
        valid = ["approve", "reject", "review_required"]
        if feedback.human_recommendation not in valid:
            raise HTTPException(400, f"recommendation must be one of {valid}")

        # Verificar se opinião existe
        opinion = opinions_col.find_one({"opinion_id": feedback.opinion_id})
        if not opinion:
            raise HTTPException(404, "Opinion not found")

        # Criar documento de feedback
        feedback_doc = {
            "feedback_id": f"fb-{datetime.utcnow().timestamp()}",
            "opinion_id": feedback.opinion_id,
            "opinion_recommendation": opinion.get("opinion", {}).get("recommendation"),
            "human_recommendation": feedback.human_recommendation,
            "human_rating": feedback.human_rating,
            "feedback_notes": feedback.feedback_notes,
            "specialist_type": opinion.get("specialist_type"),
            "submitted_at": datetime.utcnow(),
            "trace_id": opinion.get("trace_id")
        }

        result = feedback_col.insert_one(feedback_doc)

        return FeedbackResponse(
            status="success",
            feedback_id=str(result.inserted_id),
            opinion_id=feedback.opinion_id,
            message="Feedback submitted successfully"
        )

    @app.get("/api/v1/feedback/stats")
    def feedback_stats():
        """Estatísticas de feedback coletado."""
        total = opinions_col.count_documents({})
        with_feedback = feedback_col.count_documents({})
        pending = total - with_feedback

        # Distribuição de feedbacks
        pipeline = [
            {"$group": {"_id": "$human_recommendation", "count": {"$sum": 1}}}
        ]
        distribution = list(feedback_col.aggregate(pipeline))

        return {
            "total_opinions": total,
            "with_feedback": with_feedback,
            "pending_feedback": pending,
            "distribution": {d["_id"]: d["count"] for d in distribution}
        }

    if __name__ == "__main__":
        uvicorn.run(app, host="0.0.0.0", port=8080)
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: feedback-collection-service
  namespace: neural-hive
spec:
  replicas: 1
  selector:
    matchLabels:
      app: feedback-collection
  template:
    metadata:
      labels:
        app: feedback-collection
    spec:
      containers:
      - name: feedback-service
        image: python:3.11-slim
        command: ["python3"]
        args: ["/scripts/feedback_service.py"]
        ports:
        - containerPort: 8080
        volumeMounts:
        - name: scripts
          mountPath: /scripts
      volumes:
      - name: scripts
        configMap:
          name: feedback-script
---
apiVersion: v1
kind: Service
metadata:
  name: feedback-collection-service
  namespace: neural-hive
spec:
  selector:
    app: feedback-collection
  ports:
  - port: 8080
    targetPort: 8080
  type: ClusterIP
---
apiVersion: v1
kind: Service
metadata:
  name: feedback-collection-service-external
  namespace: neural-hive
spec:
  selector:
    app: feedback-collection
  ports:
  - port: 8080
    targetPort: 8080
    nodePort: 30080
  type: NodePort
