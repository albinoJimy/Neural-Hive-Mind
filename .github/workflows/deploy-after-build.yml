name: Deploy After Build

on:
  # Disparo via workflow_dispatch (chamado pelo build ou manualmente)
  workflow_dispatch:
    inputs:
      environment:
        description: 'Ambiente de deployment'
        required: true
        type: choice
        options:
          - development
          - staging
          - production
        default: 'staging'
      services:
        description: 'Servi√ßos para deploy (separados por v√≠rgula)'
        required: true
        type: string
      image_tag:
        description: 'Tag da imagem (SHA, semver ou latest)'
        required: true
        type: string
      dry_run:
        description: 'Simular deployment sem aplicar mudan√ßas'
        required: false
        type: boolean
        default: false

# Evita m√∫ltiplos deploys simult√¢neos para o mesmo ambiente
concurrency:
  group: deploy-after-build-${{ inputs.environment || 'staging' }}
  cancel-in-progress: false  # N√ÉO cancela deploys em andamento

permissions:
  contents: read

env:
  REGISTRY: ghcr.io
  IMAGE_PREFIX: albinojimy/neural-hive-mind

jobs:
  select-runner:
    name: Select Runner with Auto Fallback
    uses: ./.github/workflows/_runner-select.yml
    secrets: inherit

  # ============================================================================
  # Job 1: Prepara√ß√£o e Valida√ß√£o
  # ============================================================================
  prepare:
    name: Preparar Deployment
    needs: select-runner
    runs-on: ${{ needs.select-runner.outputs.selected-runner }}
    outputs:
      environment: ${{ inputs.environment }}
      services: ${{ inputs.services }}
      services_list: ${{ steps.parse-services.outputs.services_list }}
      image_tag: ${{ inputs.image_tag }}
      should_deploy: ${{ steps.validate.outputs.should_deploy }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Parsear lista de servi√ßos
        id: parse-services
        run: |
          SERVICES="${{ inputs.services }}"
          echo "Servi√ßos recebidos: $SERVICES"

          # Converter para JSON array
          SERVICES_JSON=$(echo "$SERVICES" | tr ',' '\n' | jq -R -s -c 'split("\n") | map(select(. != ""))')

          echo "services_list=$SERVICES_JSON" >> $GITHUB_OUTPUT
          echo "Lista JSON: $SERVICES_JSON"

      - name: Validar pr√©-requisitos
        id: validate
        run: |
          SHOULD_DEPLOY="true"

          # Verificar se √© dry-run
          if [[ "${{ inputs.dry_run }}" == "true" ]]; then
            echo "‚ö†Ô∏è Modo dry-run ativado - deployment ser√° simulado"
            SHOULD_DEPLOY="false"
          fi

          # Verificar se h√° servi√ßos para deploy
          if [[ -z "${{ inputs.services }}" ]]; then
            echo "‚ùå Nenhum servi√ßo especificado!"
            SHOULD_DEPLOY="false"
          fi

          echo "should_deploy=$SHOULD_DEPLOY" >> $GITHUB_OUTPUT

      - name: Gerar resumo de prepara√ß√£o
        run: |
          echo "## üìã Prepara√ß√£o do Deployment" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Configura√ß√£o | Valor |" >> $GITHUB_STEP_SUMMARY
          echo "|--------------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Ambiente** | ${{ inputs.environment }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Servi√ßos** | ${{ inputs.services }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Tag** | ${{ inputs.image_tag }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Dry Run** | ${{ inputs.dry_run || 'false' }} |" >> $GITHUB_STEP_SUMMARY

  # ============================================================================
  # Job 2: Atualizar Tags nos Values Files
  # ============================================================================
  update-values:
    name: Atualizar Tags - ${{ matrix.service }}
    needs: [select-runner, prepare]
    runs-on: ${{ needs.select-runner.outputs.selected-runner }}
    if: needs.prepare.outputs.should_deploy == 'true'

    strategy:
      fail-fast: false
      matrix:
        service: ${{ fromJson(needs.prepare.outputs.services_list) }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Atualizar tag da imagem
        id: update-tag
        run: |
          SERVICE="${{ matrix.service }}"
          TAG="${{ needs.prepare.outputs.image_tag }}"
          ENV="${{ needs.prepare.outputs.environment }}"
          DRY_RUN="${{ inputs.dry_run || 'false' }}"

          echo "Atualizando $SERVICE para tag $TAG no ambiente $ENV"

          # Arquivo base
          BASE_FILE="helm-charts/$SERVICE/values.yaml"

          # Arquivo espec√≠fico do ambiente
          case "$ENV" in
            production)
              ENV_FILE="environments/prod/helm-values/$SERVICE-values.yaml"
              ;;
            staging)
              ENV_FILE="environments/staging/helm-values/$SERVICE-values.yaml"
              ;;
            *)
              ENV_FILE=""
              ;;
          esac

          # Fun√ß√£o para atualizar tag
          update_tag() {
            local file="$1"
            if [[ -f "$file" ]]; then
              echo "Atualizando $file..."
              OLD_TAG=$(grep -E "^\s*tag:" "$file" | head -1 | awk '{print $2}' | tr -d '"')

              if [[ "$DRY_RUN" == "true" ]]; then
                echo "[DRY-RUN] Seria atualizado: $file"
                echo "  Tag antiga: $OLD_TAG"
                echo "  Tag nova: $TAG"
              else
                # Usar sed para atualiza√ß√£o (compat√≠vel com mais sistemas)
                sed -i "s|^\(\s*tag:\s*\).*|\1\"$TAG\"|" "$file"
                echo "‚úì Atualizado: $file (${OLD_TAG:-'N/A'} ‚Üí $TAG)"
              fi
            else
              echo "Arquivo n√£o encontrado: $file"
            fi
          }

          # Atualizar arquivos
          update_tag "$BASE_FILE"
          if [[ -n "$ENV_FILE" ]]; then
            update_tag "$ENV_FILE"
          fi

          echo "service=$SERVICE" >> $GITHUB_OUTPUT
          echo "tag=$TAG" >> $GITHUB_OUTPUT

  # ============================================================================
  # Job 3: Deploy via Helm
  # ============================================================================
  deploy:
    name: Deploy - ${{ matrix.service }}
    needs: [select-runner, prepare, update-values]
    runs-on: ${{ needs.select-runner.outputs.selected-runner }}
    if: needs.prepare.outputs.should_deploy == 'true' && inputs.dry_run != true

    # Aprova√ß√£o para produ√ß√£o
    environment:
      name: ${{ needs.prepare.outputs.environment }}

    strategy:
      fail-fast: false
      max-parallel: 2  # Reduce API load to avoid rate limiting
      matrix:
        service: ${{ fromJson(needs.prepare.outputs.services_list) }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configurar kubeconfig
        if: env.KUBECONFIG_DATA != ''
        env:
          KUBECONFIG_DATA: ${{ secrets.KUBECONFIG }}
        run: |
          mkdir -p ~/.kube
          echo "$KUBECONFIG_DATA" | base64 -d > ~/.kube/config
          chmod 600 ~/.kube/config

      - name: Instalar Helm
        uses: azure/setup-helm@v4
        with:
          version: 'v3.14.0'

      - name: Verificar kubectl
        run: |
          # Executor self-hosted ja deve ter kubectl instalado
          if command -v kubectl &> /dev/null; then
            echo "kubectl encontrado: $(kubectl version --client --short 2>/dev/null || kubectl version --client)"
          else
            echo "ERRO: kubectl nao encontrado no executor self-hosted"
            echo "Instale kubectl no runner: sudo apt-get install -y kubectl"
            exit 1
          fi

      - name: Determinar namespace
        id: namespace
        run: |
          # TEMPOR√ÅRIO: Todos os ambientes usam namespace neural-hive
          # onde j√° temos todos os servi√ßos deployados
          NAMESPACE="neural-hive"
          echo "namespace=$NAMESPACE" >> $GITHUB_OUTPUT
          echo "‚ÑπÔ∏è Usando namespace fixo: $NAMESPACE (todos ambientes)"

      - name: Adicionar reposit√≥rio de depend√™ncias Helm
        run: |
          helm repo add bitnami https://charts.bitnami.com/bitnami 2>/dev/null || true
          helm repo add neural-hive file://./helm-charts/common-templates 2>/dev/null || true
          helm repo update 2>/dev/null || true

      - name: Atualizar depend√™ncias do chart
        run: |
          SERVICE="${{ matrix.service }}"
          CHART_PATH="helm-charts/$SERVICE"

          if [[ -f "$CHART_PATH/Chart.yaml" ]]; then
            echo "Atualizando depend√™ncias de $SERVICE..."
            helm dependency update "$CHART_PATH" 2>/dev/null || true
            helm dependency build "$CHART_PATH" 2>/dev/null || true
          fi

      - name: Deploy com Helm
        id: helm-deploy
        run: |
          SERVICE="${{ matrix.service }}"
          TAG="${{ needs.prepare.outputs.image_tag }}"
          ENV="${{ needs.prepare.outputs.environment }}"
          NAMESPACE="${{ steps.namespace.outputs.namespace }}"

          echo "============================================"
          echo "üöÄ Deployando $SERVICE"
          echo "   Namespace: $NAMESPACE"
          echo "   Tag: $TAG"
          echo "   Ambiente: $ENV"
          echo "============================================"

          # Delay aleat√≥rio para reduzir conten√ß√£o (0-30s)
          RANDOM_DELAY=$((RANDOM % 30))
          echo "‚è±Ô∏è  Aguardando ${RANDOM_DELAY}s antes do deploy para reduzir conten√ß√£o..."
          sleep $RANDOM_DELAY

          # Verificar se chart existe
          CHART_PATH="helm-charts/$SERVICE"
          if [[ ! -d "$CHART_PATH" ]]; then
            echo "‚ùå Chart n√£o encontrado: $CHART_PATH"
            echo "status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi

          # Arquivo de valores do ambiente
          VALUES_FILE=""
          case "$ENV" in
            production)
              VALUES_FILE="environments/prod/helm-values/$SERVICE-values.yaml"
              ;;
            staging)
              VALUES_FILE="environments/staging/helm-values/$SERVICE-values.yaml"
              ;;
            development)
              VALUES_FILE="environments/dev/helm-values/$SERVICE-values.yaml"
              ;;
          esac

          # Construir comando helm
          HELM_ARGS=(
            "upgrade" "--install" "$SERVICE" "$CHART_PATH"
            "--namespace" "$NAMESPACE"
            "--create-namespace"
            "--set" "image.tag=$TAG"
            "--set" "image.repository=${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}/$SERVICE"
            # Removed --atomic to avoid rollback issues during rate limiting
            "--wait"
            "--timeout" "20m"  # Aumentado para servi√ßos pesados (orchestrator, etc)
          )

          # Adicionar valores do ambiente se existir
          if [[ -n "$VALUES_FILE" && -f "$VALUES_FILE" ]]; then
            echo "üìÑ Usando valores: $VALUES_FILE"
            HELM_ARGS+=("-f" "$VALUES_FILE")
          fi

          echo ""
          echo "Comando: helm ${HELM_ARGS[*]}"
          echo ""

          # Limpar locks presos do Helm antes do deploy
          echo "üîì Verificando locks presos do Helm..."
          helm list -n "$NAMESPACE" 2>/dev/null | grep -i "pending-upgrade\|pending-install\|pending-rollback" && \
            echo "‚ö†Ô∏è  Detectado release em estado pendente - pode causar conflito" || \
            echo "‚úì Nenhum lock preso detectado"

          echo ""

          # Executar com retry para erros de lock/concorr√™ncia
          if [[ -f ~/.kube/config ]]; then
            MAX_RETRIES=3
            RETRY_DELAY=30
            ATTEMPT=1

            while [[ $ATTEMPT -le $MAX_RETRIES ]]; do
              if helm "${HELM_ARGS[@]}" 2>&1 | tee /tmp/helm-output.txt; then
                echo "‚úÖ Deploy de $SERVICE conclu√≠do com sucesso!"
                echo "status=success" >> $GITHUB_OUTPUT
                break
              else
                EXIT_CODE=$?
                HELM_ERROR=$(cat /tmp/helm-output.txt)

                # Verificar se √© erro de lock/concorr√™ncia (retr√°vel)
                if [[ "$HELM_ERROR" =~ "another operation" ]] && [[ $ATTEMPT -lt $MAX_RETRIES ]]; then
                  echo "‚ö†Ô∏è  Erro de lock detectado (tentativa $ATTEMPT/$MAX_RETRIES)"
                  echo "   Aguardando ${RETRY_DELAY}s antes de retry..."
                  echo "   Isso acontece quando m√∫ltiplos deploys tentam atualizar o mesmo release."

                  # Mostrar status do lock
                  helm status "$SERVICE" -n "$NAMESPACE" 2>/dev/null || true

                  sleep $RETRY_DELAY
                  RETRY_DELAY=$((RETRY_DELAY * 2))  # Exponential backoff
                  ATTEMPT=$((ATTEMPT + 1))
                  continue
                fi

                # Erro n√£o retr√°vel ou excedeu tentativas
                echo "‚ùå Falha no deploy de $SERVICE ap√≥s $ATTEMPT tentativa(s)"
                echo "status=failed" >> $GITHUB_OUTPUT

                # Mostrar status do release para debug
                echo ""
                echo "üìä Status do release:"
                helm status "$SERVICE" -n "$NAMESPACE" 2>/dev/null || true

                echo ""
                echo "üìã Hist√≥rico do release:"
                helm history "$SERVICE" -n "$NAMESPACE" 2>/dev/null || true

                echo ""
                echo "üîç Erro:"
                echo "$HELM_ERROR"

                # Tentar liberar lock preso
                echo ""
                echo "üîì Tentando liberar lock do Helm..."
                helm list -n "$NAMESPACE" 2>/dev/null || true

                exit $EXIT_CODE
              fi
            done
          else
            echo "‚ö†Ô∏è KUBECONFIG n√£o dispon√≠vel - simulando deploy"
            echo "status=simulated" >> $GITHUB_OUTPUT
          fi

      - name: Verificar rollout
        if: steps.helm-deploy.outputs.status == 'success'
        run: |
          SERVICE="${{ matrix.service }}"
          NAMESPACE="${{ steps.namespace.outputs.namespace }}"

          echo "Verificando rollout de $SERVICE..."
          kubectl rollout status deployment/$SERVICE -n $NAMESPACE --timeout=5m || true

      - name: Verificar health
        if: steps.helm-deploy.outputs.status == 'success'
        run: |
          SERVICE="${{ matrix.service }}"
          NAMESPACE="${{ steps.namespace.outputs.namespace }}"

          echo "Verificando health dos pods..."
          kubectl get pods -n $NAMESPACE -l app.kubernetes.io/name=$SERVICE -o wide || true

  # ============================================================================
  # Job 4: Resumo Final
  # ============================================================================
  summary:
    name: Resumo do Deployment
    needs: [select-runner, prepare, update-values, deploy]
    runs-on: ${{ needs.select-runner.outputs.selected-runner }}
    if: always()

    steps:
      - name: Gerar resumo
        run: |
          echo "## üöÄ Resumo do Deployment" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Ambiente:** ${{ needs.prepare.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "**Tag:** ${{ needs.prepare.outputs.image_tag }}" >> $GITHUB_STEP_SUMMARY
          echo "**Servi√ßos:** ${{ needs.prepare.outputs.services }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [[ "${{ needs.deploy.result }}" == "success" ]]; then
            echo "### ‚úÖ Deployment Conclu√≠do com Sucesso" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ needs.deploy.result }}" == "skipped" ]]; then
            echo "### ‚è≠Ô∏è Deployment Pulado (dry-run ou condi√ß√£o n√£o atendida)" >> $GITHUB_STEP_SUMMARY
          else
            echo "### ‚ùå Deployment com Falhas" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Verifique os logs dos jobs individuais para detalhes." >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üìã Pr√≥ximos Passos" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "1. Verificar pods:" >> $GITHUB_STEP_SUMMARY
          echo '   ```bash' >> $GITHUB_STEP_SUMMARY
          echo "   kubectl get pods -n neural-hive -l app.kubernetes.io/name=<service>" >> $GITHUB_STEP_SUMMARY
          echo '   ```' >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "2. Verificar logs:" >> $GITHUB_STEP_SUMMARY
          echo '   ```bash' >> $GITHUB_STEP_SUMMARY
          echo "   kubectl logs -n neural-hive -l app.kubernetes.io/name=<service> -f" >> $GITHUB_STEP_SUMMARY
          echo '   ```' >> $GITHUB_STEP_SUMMARY

      - name: Notificar resultado
        run: |
          if [[ "${{ needs.deploy.result }}" == "success" ]]; then
            echo "‚úÖ Deployment conclu√≠do com sucesso!"
          else
            echo "‚ö†Ô∏è Deployment finalizado com status: ${{ needs.deploy.result }}"
          fi
