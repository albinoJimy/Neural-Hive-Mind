name: Deploy After Build

on:
  # Disparado automaticamente ap√≥s sucesso do build
  workflow_run:
    workflows: ["Build and Push to GHCR"]
    types: [completed]
    branches: [main, develop]

  # Disparo manual para deploys controlados
  workflow_dispatch:
    inputs:
      environment:
        description: 'Ambiente de deployment'
        required: true
        type: choice
        options:
          - development
          - staging
          - production
        default: 'staging'
      services:
        description: 'Servi√ßos para deploy (separados por v√≠rgula, vazio = todos do √∫ltimo build)'
        required: false
        type: string
        default: ''
      image_tag:
        description: 'Tag da imagem (SHA, semver ou latest)'
        required: false
        type: string
        default: ''
      dry_run:
        description: 'Simular deployment sem aplicar mudan√ßas'
        required: false
        type: boolean
        default: false

env:
  REGISTRY: ghcr.io
  IMAGE_PREFIX: albinojimy/neural-hive-mind

jobs:
  # ============================================================================
  # Job 1: Prepara√ß√£o e Valida√ß√£o
  # ============================================================================
  prepare:
    name: Preparar Deployment
    runs-on: self-hosted
    # S√≥ executa se build foi sucesso ou se √© dispatch manual
    if: >
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')
    outputs:
      environment: ${{ steps.determine-env.outputs.environment }}
      services: ${{ steps.determine-services.outputs.services }}
      services_list: ${{ steps.determine-services.outputs.services_list }}
      image_tag: ${{ steps.determine-tag.outputs.tag }}
      should_deploy: ${{ steps.validate.outputs.should_deploy }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Determinar ambiente
        id: determine-env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            ENVIRONMENT="${{ inputs.environment }}"
          else
            # Mapear branch para ambiente
            BRANCH="${{ github.event.workflow_run.head_branch || github.ref_name }}"
            case "$BRANCH" in
              main|master)
                ENVIRONMENT="production"
                ;;
              develop)
                ENVIRONMENT="staging"
                ;;
              *)
                ENVIRONMENT="development"
                ;;
            esac
          fi
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "Ambiente determinado: $ENVIRONMENT"

      - name: Baixar artifact do build
        if: github.event_name == 'workflow_run'
        uses: actions/download-artifact@v4
        with:
          name: build-info
          path: build-info/
          github-token: ${{ secrets.GITHUB_TOKEN }}
          run-id: ${{ github.event.workflow_run.id }}
        continue-on-error: true

      - name: Determinar servi√ßos
        id: determine-services
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && -n "${{ inputs.services }}" ]]; then
            # Usar servi√ßos do input manual
            SERVICES="${{ inputs.services }}"
          elif [[ "${{ github.event_name }}" == "workflow_run" ]]; then
            # Obter servi√ßos do artifact do build
            if [[ -f "build-info/services.txt" ]]; then
              SERVICES=$(cat build-info/services.txt)
              echo "Servi√ßos obtidos do artifact: $SERVICES"
            else
              echo "‚ö†Ô∏è Artifact n√£o encontrado, usando fallback"
              SERVICES="gateway-intencoes"
            fi
          else
            SERVICES="gateway-intencoes"
          fi

          # Converter para JSON array
          SERVICES_JSON=$(echo "$SERVICES" | tr ',' '\n' | jq -R -s -c 'split("\n") | map(select(. != ""))')

          echo "services=$SERVICES" >> $GITHUB_OUTPUT
          echo "services_list=$SERVICES_JSON" >> $GITHUB_OUTPUT
          echo "Servi√ßos para deploy: $SERVICES"

      - name: Determinar tag da imagem
        id: determine-tag
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && -n "${{ inputs.image_tag }}" ]]; then
            TAG="${{ inputs.image_tag }}"
          elif [[ "${{ github.event_name }}" == "workflow_run" ]]; then
            # Verificar se tem version tag no artifact
            if [[ -f "build-info/version-tag.txt" ]]; then
              VERSION_TAG=$(cat build-info/version-tag.txt)
              if [[ -n "$VERSION_TAG" && "$VERSION_TAG" != "latest" ]]; then
                TAG="$VERSION_TAG"
                echo "Usando version tag do build: $TAG"
              else
                # Usar SHA do commit
                TAG="${{ github.event.workflow_run.head_sha }}"
                TAG="${TAG:0:7}"
              fi
            else
              # Fallback: usar SHA do commit do workflow que disparou
              TAG="${{ github.event.workflow_run.head_sha }}"
              TAG="${TAG:0:7}"
            fi
          else
            TAG="latest"
          fi
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "Tag da imagem: $TAG"

      - name: Validar pr√©-requisitos
        id: validate
        run: |
          SHOULD_DEPLOY="true"

          # Verificar se √© dry-run
          if [[ "${{ inputs.dry_run }}" == "true" ]]; then
            echo "‚ö†Ô∏è Modo dry-run ativado - deployment ser√° simulado"
          fi

          # Verificar se KUBECONFIG est√° configurado (apenas warning)
          if [[ -z "${{ secrets.KUBECONFIG }}" ]]; then
            echo "‚ö†Ô∏è KUBECONFIG n√£o configurado - helm upgrade pode falhar"
          fi

          echo "should_deploy=$SHOULD_DEPLOY" >> $GITHUB_OUTPUT

      - name: Gerar resumo de prepara√ß√£o
        run: |
          echo "## üìã Prepara√ß√£o do Deployment" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Configura√ß√£o | Valor |" >> $GITHUB_STEP_SUMMARY
          echo "|--------------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Ambiente** | ${{ steps.determine-env.outputs.environment }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Servi√ßos** | ${{ steps.determine-services.outputs.services }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Tag** | ${{ steps.determine-tag.outputs.tag }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Dry Run** | ${{ inputs.dry_run || 'false' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Trigger** | ${{ github.event_name }} |" >> $GITHUB_STEP_SUMMARY

  # ============================================================================
  # Job 2: Atualizar Tags nos Values Files
  # ============================================================================
  update-values:
    name: Atualizar Tags - ${{ matrix.service }}
    runs-on: self-hosted
    needs: prepare
    if: needs.prepare.outputs.should_deploy == 'true'

    strategy:
      fail-fast: false
      matrix:
        service: ${{ fromJson(needs.prepare.outputs.services_list) }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Atualizar tag da imagem
        id: update-tag
        run: |
          SERVICE="${{ matrix.service }}"
          TAG="${{ needs.prepare.outputs.image_tag }}"
          ENV="${{ needs.prepare.outputs.environment }}"
          DRY_RUN="${{ inputs.dry_run || 'false' }}"

          echo "Atualizando $SERVICE para tag $TAG no ambiente $ENV"

          # Arquivo base
          BASE_FILE="helm-charts/$SERVICE/values.yaml"

          # Arquivo espec√≠fico do ambiente
          case "$ENV" in
            production)
              ENV_FILE="environments/prod/helm-values/$SERVICE-values.yaml"
              ;;
            staging)
              ENV_FILE="environments/staging/helm-values/$SERVICE-values.yaml"
              ;;
            *)
              ENV_FILE=""
              ;;
          esac

          # Fun√ß√£o para atualizar tag
          update_tag() {
            local file="$1"
            if [[ -f "$file" ]]; then
              echo "Atualizando $file..."
              OLD_TAG=$(grep -E "^\s*tag:" "$file" | head -1 | awk '{print $2}' | tr -d '"')

              if [[ "$DRY_RUN" == "true" ]]; then
                echo "[DRY-RUN] Seria atualizado: $file"
                echo "  Tag antiga: $OLD_TAG"
                echo "  Tag nova: $TAG"
              else
                # Usar sed para atualiza√ß√£o (compat√≠vel com mais sistemas)
                sed -i "s|^\(\s*tag:\s*\).*|\1\"$TAG\"|" "$file"
                echo "‚úì Atualizado: $file (${OLD_TAG:-'N/A'} ‚Üí $TAG)"
              fi
            else
              echo "Arquivo n√£o encontrado: $file"
            fi
          }

          # Atualizar arquivos
          update_tag "$BASE_FILE"
          if [[ -n "$ENV_FILE" ]]; then
            update_tag "$ENV_FILE"
          fi

          echo "service=$SERVICE" >> $GITHUB_OUTPUT
          echo "tag=$TAG" >> $GITHUB_OUTPUT

  # ============================================================================
  # Job 3: Deploy via Helm
  # ============================================================================
  deploy:
    name: Deploy - ${{ matrix.service }}
    runs-on: self-hosted
    needs: [prepare, update-values]
    if: needs.prepare.outputs.should_deploy == 'true' && inputs.dry_run != true

    # Aprova√ß√£o para produ√ß√£o
    environment:
      name: ${{ needs.prepare.outputs.environment }}

    strategy:
      fail-fast: false
      max-parallel: 3
      matrix:
        service: ${{ fromJson(needs.prepare.outputs.services_list) }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configurar kubeconfig
        if: env.KUBECONFIG_DATA != ''
        env:
          KUBECONFIG_DATA: ${{ secrets.KUBECONFIG }}
        run: |
          mkdir -p ~/.kube
          echo "$KUBECONFIG_DATA" | base64 -d > ~/.kube/config
          chmod 600 ~/.kube/config

      - name: Instalar Helm
        uses: azure/setup-helm@v4
        with:
          version: 'v3.14.0'

      - name: Instalar kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'v1.29.0'

      - name: Determinar namespace
        id: namespace
        run: |
          ENV="${{ needs.prepare.outputs.environment }}"
          case "$ENV" in
            production)
              NAMESPACE="neural-hive"
              ;;
            staging)
              NAMESPACE="neural-hive-staging"
              ;;
            *)
              NAMESPACE="neural-hive-dev"
              ;;
          esac
          echo "namespace=$NAMESPACE" >> $GITHUB_OUTPUT

      - name: Deploy com Helm
        id: helm-deploy
        run: |
          SERVICE="${{ matrix.service }}"
          TAG="${{ needs.prepare.outputs.image_tag }}"
          ENV="${{ needs.prepare.outputs.environment }}"
          NAMESPACE="${{ steps.namespace.outputs.namespace }}"

          echo "Deployando $SERVICE no namespace $NAMESPACE..."

          # Construir comando helm
          HELM_CMD="helm upgrade --install $SERVICE helm-charts/$SERVICE"
          HELM_CMD="$HELM_CMD --namespace $NAMESPACE --create-namespace"
          HELM_CMD="$HELM_CMD --set image.tag=$TAG"
          HELM_CMD="$HELM_CMD --set image.repository=${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}/$SERVICE"

          # Adicionar valores espec√≠ficos do ambiente
          case "$ENV" in
            production)
              if [[ -f "environments/prod/helm-values/$SERVICE-values.yaml" ]]; then
                HELM_CMD="$HELM_CMD -f environments/prod/helm-values/$SERVICE-values.yaml"
              fi
              ;;
            staging)
              if [[ -f "environments/staging/helm-values/$SERVICE-values.yaml" ]]; then
                HELM_CMD="$HELM_CMD -f environments/staging/helm-values/$SERVICE-values.yaml"
              fi
              ;;
          esac

          HELM_CMD="$HELM_CMD --wait --timeout 5m"

          echo "Comando: $HELM_CMD"

          # Executar (ou simular se n√£o houver kubeconfig)
          if [[ -f ~/.kube/config ]]; then
            eval $HELM_CMD
            echo "status=success" >> $GITHUB_OUTPUT
          else
            echo "‚ö†Ô∏è KUBECONFIG n√£o dispon√≠vel - simulando deploy"
            echo "status=simulated" >> $GITHUB_OUTPUT
          fi

      - name: Verificar rollout
        if: steps.helm-deploy.outputs.status == 'success'
        run: |
          SERVICE="${{ matrix.service }}"
          NAMESPACE="${{ steps.namespace.outputs.namespace }}"

          echo "Verificando rollout de $SERVICE..."
          kubectl rollout status deployment/$SERVICE -n $NAMESPACE --timeout=5m || true

      - name: Verificar health
        if: steps.helm-deploy.outputs.status == 'success'
        run: |
          SERVICE="${{ matrix.service }}"
          NAMESPACE="${{ steps.namespace.outputs.namespace }}"

          echo "Verificando health dos pods..."
          kubectl get pods -n $NAMESPACE -l app.kubernetes.io/name=$SERVICE -o wide || true

  # ============================================================================
  # Job 4: Resumo Final
  # ============================================================================
  summary:
    name: Resumo do Deployment
    runs-on: self-hosted
    needs: [prepare, update-values, deploy]
    if: always()

    steps:
      - name: Gerar resumo
        run: |
          echo "## üöÄ Resumo do Deployment" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Ambiente:** ${{ needs.prepare.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "**Tag:** ${{ needs.prepare.outputs.image_tag }}" >> $GITHUB_STEP_SUMMARY
          echo "**Servi√ßos:** ${{ needs.prepare.outputs.services }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [[ "${{ needs.deploy.result }}" == "success" ]]; then
            echo "### ‚úÖ Deployment Conclu√≠do com Sucesso" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ needs.deploy.result }}" == "skipped" ]]; then
            echo "### ‚è≠Ô∏è Deployment Pulado (dry-run ou condi√ß√£o n√£o atendida)" >> $GITHUB_STEP_SUMMARY
          else
            echo "### ‚ùå Deployment com Falhas" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Verifique os logs dos jobs individuais para detalhes." >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üìã Pr√≥ximos Passos" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "1. Verificar pods:" >> $GITHUB_STEP_SUMMARY
          echo '   ```bash' >> $GITHUB_STEP_SUMMARY
          echo "   kubectl get pods -n neural-hive -l app.kubernetes.io/name=<service>" >> $GITHUB_STEP_SUMMARY
          echo '   ```' >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "2. Verificar logs:" >> $GITHUB_STEP_SUMMARY
          echo '   ```bash' >> $GITHUB_STEP_SUMMARY
          echo "   kubectl logs -n neural-hive -l app.kubernetes.io/name=<service> -f" >> $GITHUB_STEP_SUMMARY
          echo '   ```' >> $GITHUB_STEP_SUMMARY

      - name: Notificar resultado
        run: |
          if [[ "${{ needs.deploy.result }}" == "success" ]]; then
            echo "‚úÖ Deployment conclu√≠do com sucesso!"
          else
            echo "‚ö†Ô∏è Deployment finalizado com status: ${{ needs.deploy.result }}"
          fi
