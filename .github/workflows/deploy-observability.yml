name: Deploy Observability Stack

on:
  push:
    branches: [ main ]
    paths:
    - 'infrastructure/terraform/modules/observability-stack/**'
    - 'helm-charts/**'
    - 'monitoring/**'
    - 'scripts/deploy.sh'
    - 'scripts/deploy/modules/observability.sh'
    - '.github/workflows/deploy-observability.yml'

  pull_request:
    branches: [ main ]
    paths:
    - 'infrastructure/terraform/modules/observability-stack/**'
    - 'helm-charts/**'
    - 'monitoring/**'
    - 'scripts/deploy.sh'
    - 'scripts/deploy/modules/observability.sh'

  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      rollback:
        description: 'Rollback to previous version'
        required: false
        default: false
        type: boolean

env:
  TERRAFORM_VERSION: "1.5.7"
  HELM_VERSION: "3.12.3"
  KUBECTL_VERSION: "1.28.0"

jobs:
  validate:
    name: Validate Configuration
    runs-on: ubuntu-latest
    outputs:
      terraform-changes: ${{ steps.changes.outputs.terraform }}
      helm-changes: ${{ steps.changes.outputs.helm }}
      monitoring-changes: ${{ steps.changes.outputs.monitoring }}

    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Detect changes
      uses: dorny/paths-filter@v2
      id: changes
      with:
        filters: |
          terraform:
            - 'infrastructure/terraform/modules/observability-stack/**'
          helm:
            - 'helm-charts/**'
          monitoring:
            - 'monitoring/**'

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TERRAFORM_VERSION }}

    - name: Setup Helm
      uses: azure/setup-helm@v3
      with:
        version: ${{ env.HELM_VERSION }}

    - name: Terraform Validate
      if: steps.changes.outputs.terraform == 'true'
      run: |
        cd infrastructure/terraform/modules/observability-stack
        terraform init -backend=false
        terraform validate

    - name: Helm Lint
      if: steps.changes.outputs.helm == 'true'
      run: |
        for chart in helm-charts/*/; do
          if [ -f "$chart/Chart.yaml" ]; then
            echo "Linting $chart"
            helm lint "$chart"
          fi
        done

    - name: Validate monitoring configs
      if: steps.changes.outputs.monitoring == 'true'
      run: |
        # Validate dashboards JSON
        for dashboard in monitoring/dashboards/*.json; do
          if [ -f "$dashboard" ]; then
            echo "Validating $dashboard"
            jq empty "$dashboard"
          fi
        done

        # Validate Prometheus rules
        for alert in monitoring/alerts/*.yaml; do
          if [ -f "$alert" ]; then
            echo "Validating $alert"
            yq eval '.' "$alert" >/dev/null
          fi
        done

  plan:
    name: Terraform Plan
    runs-on: ubuntu-latest
    needs: validate
    if: needs.validate.outputs.terraform-changes == 'true'

    strategy:
      matrix:
        environment: [ staging, production ]

    environment: ${{ matrix.environment }}

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TERRAFORM_VERSION }}

    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: us-west-2

    - name: Terraform Init
      run: |
        cd infrastructure/terraform/modules/observability-stack
        terraform init

    - name: Terraform Plan
      run: |
        cd infrastructure/terraform/modules/observability-stack
        terraform plan \
          -var-file="../../environments/${{ matrix.environment }}/terraform.tfvars" \
          -out=tfplan-${{ matrix.environment }}

    - name: Upload Plan
      uses: actions/upload-artifact@v4
      with:
        name: tfplan-${{ matrix.environment }}
        path: infrastructure/terraform/modules/observability-stack/tfplan-${{ matrix.environment }}
        retention-days: 5

  deploy-terraform:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: [ validate, plan ]
    if: github.ref == 'refs/heads/main' && !inputs.rollback

    strategy:
      matrix:
        environment: [ staging, production ]
      max-parallel: 1 # Deploy sequentially

    environment: ${{ matrix.environment }}

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TERRAFORM_VERSION }}

    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: us-west-2

    - name: Download Plan
      if: needs.validate.outputs.terraform-changes == 'true'
      uses: actions/download-artifact@v4
      with:
        name: tfplan-${{ matrix.environment }}
        path: infrastructure/terraform/modules/observability-stack/

    - name: Terraform Apply
      if: needs.validate.outputs.terraform-changes == 'true'
      run: |
        cd infrastructure/terraform/modules/observability-stack
        terraform init
        terraform apply -auto-approve tfplan-${{ matrix.environment }}

    - name: Wait for infrastructure
      if: needs.validate.outputs.terraform-changes == 'true'
      run: sleep 60

  deploy-helm:
    name: Deploy Helm Charts
    runs-on: ubuntu-latest
    needs: [ validate, deploy-terraform ]
    if: always() && !failure() && !inputs.rollback

    strategy:
      matrix:
        environment: [ staging, production ]
      max-parallel: 1

    environment: ${{ matrix.environment }}

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Setup Helm
      uses: azure/setup-helm@v3
      with:
        version: ${{ env.HELM_VERSION }}

    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: ${{ env.KUBECTL_VERSION }}

    - name: Configure kubectl
      run: |
        aws eks update-kubeconfig \
          --name neural-hive-${{ matrix.environment }} \
          --region us-west-2
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

    - name: Deploy Prometheus Stack
      if: needs.validate.outputs.helm-changes == 'true' || needs.validate.outputs.terraform-changes == 'true'
      run: |
        helm upgrade --install prometheus-stack \
          ./helm-charts/prometheus-stack \
          --namespace observability \
          --create-namespace \
          --values ./helm-charts/prometheus-stack/values-${{ matrix.environment }}.yaml \
          --timeout 10m \
          --wait

    - name: Deploy Grafana
      if: needs.validate.outputs.helm-changes == 'true' || needs.validate.outputs.terraform-changes == 'true'
      run: |
        # Create Grafana admin secret
        kubectl create secret generic grafana-admin-credentials \
          --namespace observability \
          --from-literal=admin-user=admin \
          --from-literal=admin-password="${{ secrets.GRAFANA_ADMIN_PASSWORD }}" \
          --dry-run=client -o yaml | kubectl apply -f -

        helm upgrade --install grafana \
          ./helm-charts/grafana \
          --namespace observability \
          --values ./helm-charts/grafana/values-${{ matrix.environment }}.yaml \
          --timeout 10m \
          --wait

    - name: Deploy Jaeger
      if: needs.validate.outputs.helm-changes == 'true' || needs.validate.outputs.terraform-changes == 'true'
      run: |
        helm repo add jaegertracing https://jaegertracing.github.io/helm-charts
        helm repo update

        helm upgrade --install jaeger jaegertracing/jaeger \
          --namespace observability \
          --values ./helm-charts/jaeger/values-${{ matrix.environment }}.yaml \
          --timeout 10m \
          --wait

  deploy-monitoring:
    name: Deploy Monitoring Configs
    runs-on: ubuntu-latest
    needs: [ validate, deploy-helm ]
    if: always() && !failure() && !inputs.rollback

    strategy:
      matrix:
        environment: [ staging, production ]

    environment: ${{ matrix.environment }}

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: ${{ env.KUBECTL_VERSION }}

    - name: Configure kubectl
      run: |
        aws eks update-kubeconfig \
          --name neural-hive-${{ matrix.environment }} \
          --region us-west-2
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

    - name: Deploy monitoring configurations
      if: needs.validate.outputs.monitoring-changes == 'true'
      run: |
        # Usar CLI unificado de deploy
        ./scripts/deploy.sh --env eks --services observability --version latest

    - name: Setup Grafana dashboards
      if: needs.validate.outputs.monitoring-changes == 'true'
      run: |
        # Wait for Grafana to be ready
        kubectl wait --for=condition=ready pod \
          -l app.kubernetes.io/name=grafana \
          -n observability \
          --timeout=300s

        # Port forward to access Grafana API
        kubectl port-forward svc/grafana 3000:80 -n observability &
        KUBECTL_PID=$!
        sleep 10

        # Setup dashboards usando m√≥dulo do deploy CLI
        export GRAFANA_URL="http://localhost:3000"
        export GRAFANA_API_KEY="${{ secrets.GRAFANA_API_KEY }}"
        
        # Chamar m√≥dulo de observability diretamente
        source scripts/deploy/modules/observability.sh
        setup_grafana_dashboards

        # Cleanup
        kill $KUBECTL_PID || true

  test-deployment:
    name: Test Deployment
    runs-on: ubuntu-latest
    needs: [ deploy-monitoring ]
    if: always() && !failure()

    strategy:
      matrix:
        environment: [ staging, production ]

    environment: ${{ matrix.environment }}

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: ${{ env.KUBECTL_VERSION }}

    - name: Configure kubectl
      run: |
        aws eks update-kubeconfig \
          --name neural-hive-${{ matrix.environment }} \
          --region us-west-2
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

    - name: Run observability validation
      run: |
        # Usar CLI unificado de valida√ß√£o
        ./scripts/validate.sh --target observability --report json --report-file /tmp/observability-validation.json

    - name: Health check endpoints
      run: |
        # Test internal endpoints via port-forward
        kubectl port-forward svc/prometheus-kube-prometheus-prometheus 9090:9090 -n observability &
        kubectl port-forward svc/grafana 3000:80 -n observability &
        kubectl port-forward svc/jaeger-query 16686:16686 -n observability &

        sleep 15

        # Check Prometheus
        curl -f http://localhost:9090/-/healthy || exit 1

        # Check Grafana
        curl -f http://localhost:3000/api/health || exit 1

        # Check Jaeger
        curl -f http://localhost:16686/ || exit 1

        echo "All services healthy!"

  rollback:
    name: Rollback Deployment
    runs-on: ubuntu-latest
    if: inputs.rollback

    strategy:
      matrix:
        environment: [ staging, production ]

    environment: ${{ matrix.environment }}

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Setup Helm
      uses: azure/setup-helm@v3
      with:
        version: ${{ env.HELM_VERSION }}

    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: ${{ env.KUBECTL_VERSION }}

    - name: Configure kubectl
      run: |
        aws eks update-kubeconfig \
          --name neural-hive-${{ matrix.environment }} \
          --region us-west-2
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

    - name: Rollback Helm releases
      run: |
        helm rollback grafana -n observability || true
        helm rollback prometheus-stack -n observability || true
        helm rollback jaeger -n observability || true

  notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [ test-deployment, rollback ]
    if: always()

    steps:
    - name: Notify Slack - Success
      if: needs.test-deployment.result == 'success' && !inputs.rollback
      uses: 8398a7/action-slack@v3
      with:
        status: success
        channel: '#neural-hive-deployments'
        text: |
          ‚úÖ Observability stack deployed successfully!

          Environment: ${{ github.event.inputs.environment || 'staging, production' }}
          Commit: ${{ github.sha }}
          Author: ${{ github.actor }}
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

    - name: Notify Slack - Failure
      if: failure() && !inputs.rollback
      uses: 8398a7/action-slack@v3
      with:
        status: failure
        channel: '#neural-hive-deployments'
        text: |
          ‚ùå Observability stack deployment failed!

          Environment: ${{ github.event.inputs.environment || 'staging, production' }}
          Commit: ${{ github.sha }}
          Author: ${{ github.actor }}

          Please check the workflow logs for details.
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

    - name: Notify Slack - Rollback
      if: inputs.rollback
      uses: 8398a7/action-slack@v3
      with:
        status: ${{ needs.rollback.result }}
        channel: '#neural-hive-deployments'
        text: |
          üîÑ Observability stack rollback ${{ needs.rollback.result }}

          Environment: ${{ github.event.inputs.environment }}
          Commit: ${{ github.sha }}
          Author: ${{ github.actor }}
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
