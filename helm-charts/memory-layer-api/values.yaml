# Configurações do Memory Layer API
component: "memory-layer-api"
layer: "conhecimento-dados"

image:
  repository: ghcr.io/albinojimy/neural-hive-mind/memory-layer-api
  pullPolicy: Always
  tag: "1.2.1"

imagePullSecrets:
  - name: ghcr-secret

replicaCount: 1

# Disable Kubernetes service links to prevent env var collisions with pydantic settings
enableServiceLinks: false

nameOverride: ""
fullnameOverride: ""

deployment:
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0

# Configurações do serviço
service:
  type: ClusterIP
  annotations:
    neural-hive-mind.org/component: "memory-layer-api"
  ports:
    http:
      port: 80
      targetPort: 8000
      protocol: TCP
    metrics:
      port: 8080
      targetPort: 8080
      protocol: TCP

# Configurações de ingress
ingress:
  enabled: false
  className: "istio"
  annotations:
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
  hosts:
    - host: memory-api.neural-hive-mind.org
      paths:
        - path: /
          pathType: Prefix
  tls:
    - secretName: memory-layer-api-tls
      hosts:
        - memory-api.neural-hive-mind.org

# Resources - Reduced for local development
resources:
  limits:
    cpu: 500m
    memory: 512Mi
  requests:
    cpu: 100m
    memory: 256Mi

# Autoscaling - Disabled for local development
autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 3
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80

# Node selection
nodeSelector: {}

tolerations: []

affinity:
  # Hard anti-affinity guarantees replicas land on distinct zones to protect quorum routing latency
  podAntiAffinity:
    requiredDuringSchedulingIgnoredDuringExecution:
      - labelSelector:
          matchExpressions:
            - key: app.kubernetes.io/name
              operator: In
              values: [memory-layer-api]
        topologyKey: topology.kubernetes.io/zone

# Security context
podSecurityContext:
  fsGroup: 1001
  runAsGroup: 1001
  runAsUser: 1001
  runAsNonRoot: true

securityContext:
  allowPrivilegeEscalation: false
  capabilities:
    drop: [ALL]
  readOnlyRootFilesystem: false
  runAsNonRoot: true

# Health checks
startupProbe:
  httpGet:
    path: /health
    port: http
  initialDelaySeconds: 0
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 20  # ~3.3min para sincronizar caches multi-datastore antes da validação
  successThreshold: 1

livenessProbe:
  httpGet:
    path: /health
    port: http
  initialDelaySeconds: 0
  periodSeconds: 30
  timeoutSeconds: 10
  failureThreshold: 3

readinessProbe:
  httpGet:
    path: /ready
    port: http
  initialDelaySeconds: 0
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 3

# Configurações da aplicação
config:
  environment: "prod"
  logLevel: "INFO"
  debug: false

  # Redis (Curto Prazo)
  redis:
    clusterNodes: "neural-hive-cache.redis-cluster.svc.cluster.local:6379"
    sslEnabled: false
    defaultTtl: 300
    maxTtl: 900

  # MongoDB (Operacional)
  mongodb:
    uri: "mongodb://root:local_dev_password@mongodb.mongodb-cluster.svc.cluster.local:27017"
    database: "neural_hive"
    contextCollection: "operational_context"
    lineageCollection: "data_lineage"
    qualityCollection: "data_quality_metrics"
    retentionDays: 30

  # Neo4j (Semântico)
  neo4j:
    uri: "bolt://neo4j-bolt.neo4j-cluster.svc.cluster.local:7687"
    user: "neo4j"
    database: "neo4j"
    queryTimeout: 50

  # ClickHouse (Histórico)
  clickhouse:
    host: "clickhouse-http.clickhouse-cluster.svc.cluster.local"
    port: 8123
    user: "default"
    database: "neural_hive"
    retentionMonths: 18

  # Observabilidade
  otel:
    endpoint: "http://otel-collector-neural-hive-otel-collector.observability.svc.cluster.local:4317"
  prometheus:
    port: 8080
  jaeger:
    samplingRate: 1.0

  # Roteamento de Queries
  routing:
    hotDataThresholdSeconds: 300
    warmDataThresholdDays: 30
    coldDataThresholdMonths: 18

  # Data Quality
  quality:
    checkEnabled: true
    completenessThreshold: 0.95
    accuracyThreshold: 0.95
    freshnessThresholdHours: 24

  # Feature Flags
  features:
    enableCache: true
    enableLineageTracking: true
    enableQualityMonitoring: true
    enableAutoRouting: true
    enableRealtimeSync: true

  # Kafka (Real-time Sync)
  kafka:
    bootstrapServers: "kafka-cluster-kafka-bootstrap.kafka.svc.cluster.local:9092"
    syncTopic: "memory.sync.events"
    dlqTopic: "memory.sync.events.dlq"
    consumerGroup: "memory-sync-consumer"
    securityProtocol: "PLAINTEXT"

# Secrets
secrets:
  # Redis
  redis:
    password: ""

  # MongoDB
  mongodb:
    uri: "mongodb://root:local_dev_password@mongodb.mongodb-cluster.svc.cluster.local:27017"

  # Neo4j
  neo4j:
    password: "change-in-production"

  # ClickHouse
  clickhouse:
    password: "change-in-production"

# Service Monitor para Prometheus
serviceMonitor:
  enabled: true
  interval: 30s
  path: /metrics
  labels:
    neural-hive-mind.org/monitoring: "enabled"

observability:
  prometheus:
    enabled: true

topologySpreadConstraints:
  - maxSkew: 1
    topologyKey: topology.kubernetes.io/zone
    whenUnsatisfiable: ScheduleAnyway
    labelSelector:
      matchLabels:
        app.kubernetes.io/name: memory-layer-api

# Network Policy
networkPolicy:
  enabled: true
  ingress:
    - from:
        - namespaceSelector:
            matchLabels:
              name: istio-system
        - namespaceSelector:
            matchLabels:
              name: monitoring
        - podSelector:
            matchLabels:
              neural-hive-mind.org/memory-access: "enabled"
  egress:
    - to:
        - namespaceSelector:
            matchLabels:
              name: redis-cluster
      ports:
        - protocol: TCP
          port: 6379
    - to:
        - namespaceSelector:
            matchLabels:
              name: mongodb-cluster
      ports:
        - protocol: TCP
          port: 27017
    - to:
        - namespaceSelector:
            matchLabels:
              name: neo4j-cluster
      ports:
        - protocol: TCP
          port: 7687
    - to:
        - namespaceSelector:
            matchLabels:
              name: clickhouse-cluster
      ports:
        - protocol: TCP
          port: 8123

# Pod Disruption Budget
podDisruptionBudget:
  enabled: true
  minAvailable: 1

# Istio configuration
istio:
  enabled: true
  sidecar:
    inject: true
  virtualService:
    enabled: false
  gateway:
    enabled: false

# Environment específicos
environments:
  dev:
    replicaCount: 1
    resources:
      limits:
        cpu: 1000m
        memory: 1Gi
      requests:
        cpu: 250m
        memory: 512Mi
    config:
      debug: true
      logLevel: "DEBUG"

  staging:
    replicaCount: 2
    config:
      logLevel: "INFO"

  prod:
    replicaCount: 2
    config:
      logLevel: "WARNING"

# CronJobs configuration
sync:
  enabled: true
  schedule: "0 */6 * * *"  # A cada 6 horas
  batchSize: 1000
  lookbackHours: 24
  resources:
    requests:
      cpu: 100m
      memory: 256Mi
    limits:
      cpu: 500m
      memory: 512Mi

retention:
  enabled: true
  schedule: "0 2 * * *"  # Diariamente às 2h AM
  dryRun: false
  resources:
    requests:
      cpu: 100m
      memory: 256Mi
    limits:
      cpu: 500m
      memory: 512Mi

quality:
  enabled: true
  schedule: "0 */4 * * *"  # A cada 4 horas
  resources:
    requests:
      cpu: 100m
      memory: 256Mi
    limits:
      cpu: 500m
      memory: 512Mi

# Sync Consumer (Kafka -> ClickHouse)
syncConsumer:
  enabled: true
  replicaCount: 2
  resources:
    requests:
      cpu: 250m
      memory: 512Mi
    limits:
      cpu: 500m
      memory: 1Gi

# Service Account
serviceAccount:
  create: false
  annotations: {}
  name: ""
