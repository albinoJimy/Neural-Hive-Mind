nameOverride: ""
fullnameOverride: ""

image:
  repository: ghcr.io/albinojimy/neural-hive-mind/self-healing-engine
  tag: "1.2.0"
  pullPolicy: Always

imagePullSecrets:
  - name: ghcr-secret

replicaCount: 2

autoscaling:
  enabled: true
  minReplicas: 2
  maxReplicas: 10
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80

resources:
  requests:
    cpu: 100m  # Reduced from 300m - actual usage ~20-40m
    memory: 256Mi  # Reduced from 512Mi
  limits:
    cpu: 400m  # Reduced from 1200m
    memory: 768Mi  # Reduced from 1536Mi

config:
  serviceName: self-healing-engine
  namespace: neural-hive-resilience

  kafka:
    bootstrapServers: neural-hive-kafka-kafka-bootstrap.kafka.svc.cluster.local:9092
    remediationTopic: remediation-actions
    consumerGroupId: self-healing-engine

  serviceRegistry:
    host: service-registry.neural-hive-registry.svc.cluster.local
    port: 50051
    heartbeatIntervalSeconds: 30
    capabilities:
      - playbook-execution
      - auto-remediation
      - rollback
      - validation

  mongodb:
    # Password injected via Secret (MONGODB_PASSWORD env var)
    uri: mongodb://root@mongodb.mongodb-cluster.svc.cluster.local:27017
    database: neural_hive
    remediationCollection: remediation_actions
    playbookExecutionsCollection: playbook_executions

  redis:
    host: neural-hive-cache.redis-cluster.svc.cluster.local
    port: 6379
    db: 0

  kubernetes:
    inCluster: true
    namespace: neural-hive-resilience

  playbooks:
    dir: /app/playbooks
    timeoutSeconds: 300
    maxRetries: 2
    validationEnabled: true

  execution:
    maxConcurrentExecutions: 5
    executionTimeoutSeconds: 600
    rollbackOnFailure: true

  # Integration: Execution Ticket Service
  executionTicketService:
    url: http://execution-ticket-service.neural-hive-orchestration.svc.cluster.local:8000
    timeout: 30
    circuitBreaker:
      threshold: 5
      resetSeconds: 60

  # Integration: Orchestrator Dynamic (gRPC)
  orchestrator:
    grpcHost: orchestrator-dynamic.neural-hive-orchestration.svc.cluster.local
    grpcPort: 50052
    useTls: true
    timeout: 10

  # Integration: OPA Policy Engine
  opa:
    host: opa.neural-hive-governance.svc.cluster.local
    port: 8181
    enabled: true
    failOpen: true
    policyPath: neuralhive/self_healing/playbook_validation

  observability:
    otelEndpoint: http://otel-collector:4317
    prometheusPort: 9090
    httpPort: 8080
    grpcPort: 50051
    logLevel: INFO

# Secrets configuration
# Use existingSecret para referenciar secrets criados pelo create-phase2-secrets.sh
# Os Helm charts usam secretKeyRef para ler valores diretamente dos secrets K8s
secrets:
  existingSecret: "self-healing-engine-secrets"
  # Mapeamento de chaves do secret para variáveis de ambiente
  mongodbPasswordKey: MONGODB_PASSWORD
  redisPasswordKey: REDIS_PASSWORD
  kafkaSaslPasswordKey: KAFKA_SASL_PASSWORD
  pagerdutyApiKeyKey: PAGERDUTY_API_KEY
  slackWebhookUrlKey: SLACK_WEBHOOK_URL

# Observability configuration for common templates
observability:
  prometheus:
    enabled: true
  # TLS Configuration para OpenTelemetry Exporter
  tls:
    enabled: false  # Habilitar em produção
    certSecret: "neural-hive-otel-client-certs"
    mountPath: "/etc/otel-tls"

# Deployment strategy
deployment:
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0

service:
  type: ClusterIP
  ports:
    http:
      port: 8080
      targetPort: 8080
    grpc:
      port: 50051
      targetPort: 50051
    metrics:
      port: 9090
      targetPort: 9090

podSecurityContext:
  runAsNonRoot: true
  runAsUser: 1001
  fsGroup: 1001

startupProbe:
  httpGet:
    path: /health/live
    port: http
  initialDelaySeconds: 10
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 18
  successThreshold: 1

livenessProbe:
  httpGet:
    path: /health/live
    port: http
  initialDelaySeconds: 0
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 3

readinessProbe:
  httpGet:
    path: /health/ready
    port: http
  initialDelaySeconds: 10
  periodSeconds: 5
  timeoutSeconds: 3
  failureThreshold: 3

serviceAccount:
  create: true
  annotations: {}

rbac:
  create: true

istio:
  enabled: true
  mtls:
    mode: STRICT

podAnnotations:
  prometheus.io/scrape: "true"
  prometheus.io/port: "9090"
  prometheus.io/path: "/metrics"

podLabels:
  app.kubernetes.io/component: self-healing
  neural-hive.io/layer: resilience
  neural-hive.io/domain: remediation

serviceMonitor:
  enabled: false
  interval: 30s
  scrapeTimeout: 10s

networkPolicy:
  enabled: false
  ingress:
  - namespace: observability
    ports: [9090]
  - namespace: istio-system
    ports: [8080]
  - namespace: neural-hive-services
    ports: [50051]
  egress:
  # DNS resolution
  - namespaceSelector: {}
    ports:
    - port: 53
      protocol: UDP
  # Kafka
  - namespaceSelector:
      matchLabels: kafka
    ports:
    - port: 9092
  # Service Registry gRPC
  - namespaceSelector:
      matchLabels: neural-hive-registry
    ports:
    - port: 50051
  # MongoDB
  - namespaceSelector:
      matchLabels: mongodb-cluster
    ports:
    - port: 27017
  # Redis
  - namespaceSelector:
      matchLabels: redis-cluster
    ports:
    - port: 6379
  # External HTTPS (K8s API)
  - namespaceSelector:
      matchLabels: default
    ports:
    - port: 443
  # OpenTelemetry Collector
  - namespaceSelector:
      matchLabels: observability
    ports:
    - port: 4317
  # Execution Ticket Service (HTTP)
  - namespaceSelector:
      matchLabels: neural-hive-orchestration
    ports:
    - port: 8000
  # Orchestrator Dynamic (gRPC)
  - namespaceSelector:
      matchLabels: neural-hive-orchestration
    ports:
    - port: 50052
  # OPA Policy Engine (HTTP)
  - namespaceSelector:
      matchLabels: neural-hive-governance
    ports:
    - port: 8181

podDisruptionBudget:
  enabled: true
  minAvailable: 1

affinity:
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        podAffinityTerm:
          labelSelector:
            matchExpressions:
              - key: app
                operator: In
                values:
                  - self-healing-engine
          topologyKey: kubernetes.io/hostname

tolerations: []

nodeSelector: {}

topologySpreadConstraints:
  - maxSkew: 1
    topologyKey: topology.kubernetes.io/zone
    whenUnsatisfiable: ScheduleAnyway
    labelSelector:
      matchLabels:
        app.kubernetes.io/name: self-healing-engine
