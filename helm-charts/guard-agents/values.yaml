component: "guard-agents"
layer: "resilience"

image:
  repository: ghcr.io/albinojimy/neural-hive-mind/guard-agents
  tag: "1.2.0"
  pullPolicy: Always

imagePullSecrets:
  - name: ghcr-secret

replicaCount: 2

autoscaling:
  enabled: true
  minReplicas: 2
  maxReplicas: 10
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80

resources:
  requests:
    cpu: 250m
    memory: 512Mi
  limits:
    cpu: 1000m
    memory: 2Gi

config:
  serviceName: guard-agents
  environment: production
  namespace: neural-hive

  kafka:
    bootstrapServers: neural-hive-kafka-kafka-bootstrap.kafka.svc.cluster.local:9092
    incidentsTopic: security-incidents
    orchestrationIncidentsTopic: orchestration-incidents
    remediationTopic: remediation-actions
    ticketsTopic: execution.tickets
    ticketsValidatedTopic: execution.tickets.validated
    ticketsRejectedTopic: execution.tickets.rejected
    ticketsPendingApprovalTopic: execution.tickets.pending_approval
    validationsTopic: security.validations
    consumerGroupId: guard-agents

  serviceRegistry:
    host: service-registry.neural-hive.svc.cluster.local
    port: 50051
    heartbeatIntervalSeconds: 30
    capabilities:
      - threat-detection
      - policy-enforcement
      - incident-classification
      - auto-remediation
      - ticket-validation
      - secrets-scanning
      - guardrail-enforcement

  mongodb:
    # Password incluída para compatibilidade (production deveria usar Secret)
    uri: mongodb://root:local_dev_password@mongodb.mongodb-cluster.svc.cluster.local:27017
    database: neural_hive
    incidentsCollection: security_incidents
    remediationCollection: remediation_actions
    validationsCollection: security_validations
    postmortemsCollection: incident_postmortems

  keycloak:
    # Keycloak Admin API para revogacao de tokens e sessoes
    url: http://keycloak.auth.svc.cluster.local:8080
    realm: neural-hive
    adminClientId: guard-agents-admin
    # Secret injected via Secret (KEYCLOAK_ADMIN_CLIENT_SECRET env var)
    adminTimeoutSeconds: 10
    tokenCacheTtlSeconds: 300

  redis:
    host: neural-hive-cache.redis-cluster.svc.cluster.local
    port: 6379
    db: 0

  prometheus:
    url: http://prometheus.observability.svc.cluster.local:9090
    queryTimeoutSeconds: 10

  alertmanager:
    url: http://alertmanager.observability.svc.cluster.local:9093
    webhookEnabled: true

  kubernetes:
    inCluster: true
    namespace: neural-hive

  selfHealingEngine:
    url: http://self-healing-engine:8080
    grpcHost: self-healing-engine
    grpcPort: 50051

  detection:
    mttdTargetSeconds: 15
    mttrTargetSeconds: 90
    anomalyThreshold: 0.8
    falsePositiveThreshold: 0.05

  anomalyDetector:
    enabled: true
    modelType: isolation_forest
    contamination: 0.05

  # ITSM Integration for critical incident escalation
  itsm:
    enabled: false
    type: webhook  # servicenow, jira, pagerduty, opsgenie, webhook
    url: ""
    # API key injected via Secret (ITSM_API_KEY env var)
    timeoutSeconds: 30

  # ChaosMesh for chaos engineering experiments
  chaosMesh:
    enabled: false
    namespace: chaos-testing

  # Script execution for custom remediation
  scriptExecution:
    enabled: false
    namespace: neural-hive
    serviceAccount: guard-agents-executor
    defaultImage: alpine:3.18
    timeoutSeconds: 300

  enforcement:
    opaEnabled: true
    istioEnabled: true
    autoRemediationEnabled: true
    manualApprovalRequiredForCritical: true

  # OPA Configuration
  opa:
    url: http://opa:8181
    timeoutSeconds: 5
    enforcementEnabled: true
    # Policy paths for evaluation
    securityPolicyPath: data.neuralhive.guard.security_policies.result
    compliancePolicyPath: data.neuralhive.guard.compliance_policies.result
    resourcePolicyPath: data.neuralhive.guard.resource_policies.result

  # Security Policy Thresholds
  securityPolicies:
    maxVulnerabilitySeverity: HIGH
    requireSignedImages: true
    requireNetworkPoliciesProduction: true
    allowedCapabilities:
      - NET_BIND_SERVICE

  # Compliance Policy Thresholds
  compliancePolicies:
    requiredRegulations:
      - GDPR
    maxRetentionDays: 365
    maxPiiRetentionDays: 180
    requireEncryptionAtRest: true
    requireAuditLogging: true
    minAuditRetentionDays: 365

  # Resource Policy Thresholds
  resourcePolicies:
    maxCpuPerContainer: "4000m"
    maxMemoryPerContainer: "8Gi"
    minReplicasProduction: 2
    maxReplicas: 100
    requireHpaProduction: true
    minCpuUtilizationPercent: 20
    minMemoryUtilizationPercent: 20

  validation:
    enabled: true
    vault:
      enabled: true
      addr: http://vault:8200
      namespace: neural-hive
      failOpen: false
    trivy:
      enabled: true
      url: http://trivy:8080
      timeoutSeconds: 30
    thresholds:
      riskScoreAutoApprove: 0.3
      riskScoreAutoReject: 0.9
      requireApprovalForProduction: true
      requireApprovalForCriticalRisk: true
    guardrails:
      enabled: true
      mode: BLOCKING
      maxBlastRadiusPercentage: 0.1

  observability:
    otelEndpoint: http://otel-collector:4317
    prometheusPort: 9090
    httpPort: 8080
    grpcPort: 50051
    logLevel: INFO

service:
  type: ClusterIP
  ports:
    http:
      port: 8080
      targetPort: 8080
      protocol: TCP
    grpc:
      port: 50051
      targetPort: 50051
      protocol: TCP
    metrics:
      port: 9090
      targetPort: 9090
      protocol: TCP

securityContext:
  runAsNonRoot: true
  runAsUser: 1000
  fsGroup: 1000

deployment:
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0

observability:
  prometheus:
    enabled: true
  # TLS Configuration para OpenTelemetry Exporter
  tls:
    enabled: false  # Habilitar em produção
    certSecret: "neural-hive-otel-client-certs"
    mountPath: "/etc/otel-tls"

podSecurityContext:
  runAsNonRoot: true
  runAsUser: 1000
  fsGroup: 1000

livenessProbe:
  httpGet:
    path: /health/liveness
    port: http
  initialDelaySeconds: 30
  periodSeconds: 10

readinessProbe:
  httpGet:
    path: /health/readiness
    port: http
  initialDelaySeconds: 10
  periodSeconds: 5

startupProbe:
  httpGet:
    path: /health/startup
    port: http
  failureThreshold: 30
  periodSeconds: 10

serviceAccount:
  create: true
  annotations: {}

rbac:
  create: true

istio:
  enabled: true
  mtls:
    mode: STRICT

serviceMonitor:
  enabled: true
  interval: 30s

podDisruptionBudget:
  enabled: true
  minAvailable: 1

affinity:
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        podAffinityTerm:
          labelSelector:
            matchExpressions:
              - key: app
                operator: In
                values:
                  - guard-agents
          topologyKey: kubernetes.io/hostname

tolerations: []

nodeSelector: {}

networkPolicy:
  enabled: true

# Secrets configuration
# Use existingSecret para referenciar secrets criados pelo create-phase2-secrets.sh
# Os Helm charts usam secretKeyRef para ler valores diretamente dos secrets K8s
secrets:
  existingSecret: "guard-agents-secrets"
  # Mapeamento de chaves do secret para variáveis de ambiente
  mongodbPasswordKey: MONGODB_PASSWORD
  redisPasswordKey: REDIS_PASSWORD
  kafkaSaslUsernameKey: KAFKA_SASL_USERNAME
  kafkaSaslPasswordKey: KAFKA_SASL_PASSWORD
  keycloakAdminClientSecretKey: KEYCLOAK_ADMIN_CLIENT_SECRET
  itsmApiKeyKey: ITSM_API_KEY

topologySpreadConstraints:
  - maxSkew: 1
    topologyKey: topology.kubernetes.io/zone
    whenUnsatisfiable: ScheduleAnyway
    labelSelector:
      matchLabels:
        app.kubernetes.io/name: guard-agents
