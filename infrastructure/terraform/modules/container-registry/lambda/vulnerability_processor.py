import json
import boto3
import os
import logging
from botocore.exceptions import ClientError

# Configurar logging estruturado
logger = logging.getLogger()
logger.setLevel(logging.INFO)

# Clientes AWS
ecr = boto3.client('ecr')
sns = boto3.client('sns')

def handler(event, context):
    """
    Processa findings de vulnerabilidades ECR e toma ações apropriadas.
    """

    # Validar entrada do evento
    if not event or 'detail' not in event:
        logger.error("Evento malformado recebido")
        return {
            'statusCode': 400,
            'body': json.dumps({'error': 'Evento malformado'})
        }

    # Configurações do ambiente
    try:
        sns_topic_arn = os.environ['SNS_TOPIC_ARN']
        critical_threshold = int(os.environ.get('CRITICAL_SEVERITY_THRESHOLD', '0'))
    except KeyError as e:
        logger.error(f"Variável de ambiente ausente: {str(e)}")
        return {
            'statusCode': 500,
            'body': json.dumps({'error': f'Configuração ausente: {str(e)}'})
        }

    # Parse do evento
    detail = event.get('detail', {})
    repository_name = detail.get('repository-name')
    scan_status = detail.get('scan-status')

    if not repository_name:
        logger.warning("Nome do repositório não encontrado no evento")
        return {
            'statusCode': 400,
            'body': json.dumps({'error': 'Nome do repositório ausente'})
        }

    if scan_status != 'COMPLETE':
        logger.info(f"Scan ainda não completo para {repository_name}")
        return {
            'statusCode': 202,
            'body': json.dumps({'status': 'Scan em progresso'})
        }

    # Obter detalhes do scan com retry logic
    max_retries = 3
    retry_count = 0

    while retry_count < max_retries:
        try:
            response = ecr.describe_image_scan_findings(
                repositoryName=repository_name,
                imageId={
                    'imageDigest': detail.get('image-digest', ''),
                    'imageTag': detail.get('image-tags', ['latest'])[0] if detail.get('image-tags') else 'latest'
                }
            )
            break
        except ClientError as e:
            retry_count += 1
            logger.warning(f"Tentativa {retry_count} de {max_retries} falhou: {str(e)}")
            if retry_count >= max_retries:
                logger.error(f"Erro ao obter findings após {max_retries} tentativas: {str(e)}")
                return {
                    'statusCode': 500,
                    'body': json.dumps({'error': 'Falha ao obter scan findings'})
                }
            # Aguardar antes de tentar novamente (exponential backoff seria ideal em produção)
            import time
            time.sleep(2 ** retry_count)

    # Analisar severidades
    findings = response.get('imageScanFindings', {})
    severity_counts = findings.get('findingSeverityCounts', {})

    critical_count = severity_counts.get('CRITICAL', 0)
    high_count = severity_counts.get('HIGH', 0)
    medium_count = severity_counts.get('MEDIUM', 0)
    low_count = severity_counts.get('LOW', 0)

    # Construir mensagem de notificação
    message = {
        'repository': repository_name,
        'image_digest': detail.get('image-digest'),
        'image_tags': detail.get('image-tags', []),
        'severity_counts': {
            'critical': critical_count,
            'high': high_count,
            'medium': medium_count,
            'low': low_count
        },
        'action_taken': 'none'
    }

    # Verificar se excede threshold crítico
    if critical_count > critical_threshold:
        message['action_taken'] = 'blocked'
        message['reason'] = f'Vulnerabilidades críticas ({critical_count}) excedem threshold ({critical_threshold})'

        # Marcar imagem como quarentena
        try:
            # Primeiro, garantir que o repositório tenha mutabilidade de tags habilitada
            ecr.put_image_tag_mutability(
                repositoryName=repository_name,
                imageTagMutability='MUTABLE'
            )

            # Obter o manifesto da imagem
            get_image_response = ecr.batch_get_image(
                repositoryName=repository_name,
                imageIds=[
                    {
                        'imageDigest': detail.get('image-digest')
                    }
                ]
            )

            if get_image_response.get('images'):
                image_manifest = get_image_response['images'][0]['imageManifest']

                # Adicionar tag de quarentena usando put_image
                ecr.put_image(
                    repositoryName=repository_name,
                    imageManifest=image_manifest,
                    imageTag='QUARANTINED'
                )

                # Também adicionar timestamp da quarentena
                import datetime
                quarantine_tag = f"QUARANTINED-{datetime.datetime.utcnow().strftime('%Y%m%d-%H%M%S')}"
                ecr.put_image(
                    repositoryName=repository_name,
                    imageManifest=image_manifest,
                    imageTag=quarantine_tag
                )

                message['quarantine'] = True
                message['quarantine_tags'] = ['QUARANTINED', quarantine_tag]
                logger.info(f"Imagem {detail.get('image-digest')} marcada como quarentena")
            else:
                logger.error("Não foi possível obter manifesto da imagem")
                message['quarantine_error'] = "Manifesto da imagem não encontrado"

        except ClientError as e:
            logger.error(f"Erro ao marcar imagem como quarentena: {str(e)}")
            message['quarantine_error'] = str(e)

    # Enviar notificação SNS
    try:
        sns.publish(
            TopicArn=sns_topic_arn,
            Subject=f"ECR Vulnerability Scan - {repository_name}",
            Message=json.dumps(message, indent=2),
            MessageAttributes={
                'severity': {
                    'DataType': 'String',
                    'StringValue': 'CRITICAL' if critical_count > 0 else 'INFO'
                },
                'repository': {
                    'DataType': 'String',
                    'StringValue': repository_name
                }
            }
        )
        logger.info(f"Notificação SNS enviada para {repository_name}")
    except ClientError as e:
        logger.error(f"Erro ao enviar notificação SNS: {str(e)}")
        # Não falhar a função se a notificação falhar

    # Log detalhado para CloudWatch
    logger.info(json.dumps(message, indent=2))

    return {
        'statusCode': 200,
        'body': json.dumps(message)
    }